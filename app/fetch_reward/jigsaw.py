from datetime import datetime, timedelta, timezone
from typing import TYPE_CHECKING, Any, Callable, Optional
from uuid import uuid4

import requests
import sentry_sdk

from cryptography.fernet import Fernet
from fastapi import status
from retry_tasks_lib.db.models import RetryTask, TaskTypeKey, TaskTypeKeyValue
from sqlalchemy.dialects.postgresql import insert
from sqlalchemy.future import select

from app.core.config import redis_raw, settings
from app.db.base_class import sync_run_query
from app.fetch_reward.base import AgentError, BaseAgent
from app.models import Reward

if TYPE_CHECKING:  # pragma: no cover
    from inspect import Traceback

    from sqlalchemy.orm import Session

    from app.models import RewardConfig


class Jigsaw(BaseAgent):
    """
    Handles fetching a Reward from Jigsaw.

    Sample agent_config:
    ```yaml
    base_url: "https://dev.jigsaw360.com"
    brand_id: 30
    ```

    Sample getToken success response payload:
    ```json
    {
        "status": 2000,
        "status_description": "OK",
        "messages": [],
        "PartnerRef": "",
        "data": {
            "__type": "Response.getToken:#Jigsaw.API.Service",
            "Token": "sample-auth-token",
            "Expires": "2022-01-19 09:38:00",
            "TestMode": true
        }
    }
    ```

    Sample register success response payload:
    ```json
    {
        "status": 2000,
        "status_description": "OK",
        "messages": [],
        "PartnerRef": "",
        "data": {
            "__type": "Response_Data.cardData:#Order_V4",
            "customer_card_ref": "UUID generated by us",
            "reference": "339069",
            "number": "Reward.code Jigsaw send us back",
            "pin": "",
            "transaction_value": 10,
            "expiry_date": "2024-01-19T23:59:59+00:00",
            "balance": 10,
            "voucher_url": "https://egift.jigsawgiftcardteam.com/evoucher/download?...",
            "card_status": 1
        }
    }
    ```
    """

    JIGSAW_STATUS_CODE_MAP = {
        "5000": status.HTTP_500_INTERNAL_SERVER_ERROR,
        "5003": status.HTTP_503_SERVICE_UNAVAILABLE,
        "4003": status.HTTP_403_FORBIDDEN,
        "4001": status.HTTP_401_UNAUTHORIZED,
    }
    NEW_TOKEN_NEEDED_STATUS = "4001"
    NEW_TOKEN_NEEDED_IDS = ["10003", "10006", "10007"]

    redis_token_key = f"{settings.REDIS_KEY_PREFIX}:agent:jigsaw:auth_token"

    def __init__(
        self,
        db_session: "Session",
        reward_config: "RewardConfig",
        config: dict,
        send_request_fn: Callable = None,
        retry_task: RetryTask = None,
    ) -> None:
        super().__init__(db_session, reward_config, config, send_request_fn, retry_task)
        self.base_url: str = self.config["base_url"]
        self.customer_card_ref: Optional[str] = None
        self.reward_config_required_values = reward_config.load_required_fields_values()
        self.fernet = Fernet(settings.JIGSAW_AGENT_ENCRYPTION_KEY.encode())

    def _collect_response_data(self, resp: requests.Response) -> tuple[dict, str, str, str, str]:
        """tries to collect json payload, jigsaw status, status description, and error message if present."""
        try:
            response_payload = resp.json()
            jigsaw_status = str(response_payload["status"])
            description = response_payload["status_description"]
            error_msg = next((msg for msg in response_payload.get("messages", []) if msg["isError"]), None)

            if error_msg is not None:
                msg_id = str(error_msg["id"])
                msg_info = error_msg["info"]
            else:
                msg_id = "N/A"
                msg_info = ""

        except (requests.exceptions.JSONDecodeError, KeyError) as ex:
            raise requests.HTTPError(f"Jigsaw: unexpected response format. info: {ex}", response=resp)

        return response_payload, jigsaw_status, description, msg_id, msg_info

    def _get_response_body_or_raise_for_status(
        self, resp: requests.Response, try_again_call: Optional[Callable] = None
    ) -> dict:
        """Validates a http response based on Jigsaw specific status codes and errors ids."""

        response_payload, jigsaw_status, description, msg_id, msg_info = self._collect_response_data(resp)

        # BPL-437: If jigsaw returns a 4001 status with a message with isError set as True and the id equal to
        # one of the ids in NEW_TOKEN_NEEDED_IDS we need to fetch a new authorisation token and try again.
        wipe_cached_token_and_try_again = (
            try_again_call is not None
            and jigsaw_status == self.NEW_TOKEN_NEEDED_STATUS
            and msg_id in self.NEW_TOKEN_NEEDED_IDS
        )

        if not wipe_cached_token_and_try_again and jigsaw_status in self.JIGSAW_STATUS_CODE_MAP.keys():
            resp.status_code = self.JIGSAW_STATUS_CODE_MAP[jigsaw_status]
            raise requests.HTTPError(
                f"Received a {jigsaw_status} {description} response. Details: {msg_id} {msg_info}",
                response=resp,
            )

        if self.retry_task is not None:
            self.retry_task.update_task(
                db_session=self.db_session,
                response_audit={
                    "timestamp": datetime.now(tz=timezone.utc).isoformat(),
                    "request": {"method": resp.request.method, "url": resp.request.url},
                    "response": {
                        "status": resp.status_code,
                        "jigsaw_status": f"{jigsaw_status} {description}",
                        "message": f"{msg_id} {msg_info}",
                    },
                },
            )

        # we want to capture the failed response's audit before trying again.
        if wipe_cached_token_and_try_again:
            redis_raw.delete(self.redis_token_key)
            new_resp = try_again_call()  # type: ignore [misc]
            return self._get_response_body_or_raise_for_status(new_resp)

        if jigsaw_status != "2000":
            raise AgentError(
                f"Jigsaw: unknown error returned. "
                f"status: {jigsaw_status} {description}, message: {msg_id} {msg_info}"
            )

        return response_payload

    def _get_tz_aware_datetime_from_isoformat(self, date_time_str: str) -> datetime:
        """Returns a UTC timezone aware datetime from an isoformat string, assumes UTC if timezone is not specified"""

        dt = datetime.fromisoformat(date_time_str)
        if dt.tzinfo is None:
            self.logger.info("Jigsaw: Received naive datetime, assuming UTC timezone.")
            dt = dt.replace(tzinfo=timezone.utc)

        return dt.astimezone(tz=timezone.utc)

    def _get_and_decrypt_token(self) -> Optional[str]:
        """tries to fetch and decrypt token from redis, returns the token as a string on success and None on failure."""

        raw_token = redis_raw.get(self.redis_token_key)
        if raw_token is None:
            return None

        try:
            return self.fernet.decrypt(raw_token).decode()
        except Exception as ex:
            sentry_sdk.capture_exception(ex)
            self.logger.exception(
                f"Jigsaw: Unexpected value retrieved from redis for {self.redis_token_key}.", exc_info=ex
            )
            return None

    def _encrypt_and_set_token(self, token: str, expires_in: timedelta) -> None:
        """tries to encrypt the provided token and store it in redis."""

        try:
            redis_raw.set(
                self.redis_token_key,
                self.fernet.encrypt(token.encode()),
                expires_in,
            )
        except Exception as ex:
            sentry_sdk.capture_exception(ex)
            self.logger.exception("Jigsaw: Unexpected error while encrypting and saving token to redis.", exc_info=ex)

    def _get_auth_token(self) -> str:
        """
        Fetches a Jigsaw's authorisation token from redis.
        If it cannot find it cached, requests a new one to Jigsaw, caches it, and returns it.
        """

        token = self._get_and_decrypt_token()
        if token is not None:
            return token

        resp = self.send_request(
            "POST",
            f"{self.base_url}/order/V4/getToken",
            json={
                "Username": settings.JIGSAW_AGENT_USERNAME,
                "Password": settings.JIGSAW_AGENT_PASSWORD,
            },
        )

        response_payload = self._get_response_body_or_raise_for_status(resp)
        expires_in = self._get_tz_aware_datetime_from_isoformat(response_payload["data"]["Expires"]) - datetime.now(
            tz=timezone.utc
        )
        if expires_in.total_seconds() <= 0:
            raise AgentError("Jigsaw: Jigsaw returned an already expired token.")

        token = response_payload["data"]["Token"]
        self._encrypt_and_set_token(token, expires_in)
        return token

    def _generate_customer_card_ref(self) -> tuple[str, datetime]:
        """
        Generates a new customer_card_ref uuid and a datetime now utc.
        If a customer_card_ref is stored as task param, returns that instead of creating a new uuid.
        """

        customer_card_ref: Optional[str] = None
        if self.retry_task is not None:
            customer_card_ref = self.retry_task.get_params().get("customer_card_ref", None)

        self.customer_card_ref = str(uuid4()) if customer_card_ref is None else customer_card_ref
        return self.customer_card_ref, datetime.now(tz=timezone.utc)

    def _save_reward(self, customer_card_ref: str, reward_code: str) -> Reward:
        """Stores the Reward data returned by Jigsaw in the DB"""

        def _query() -> Reward:
            reward = Reward(
                id=customer_card_ref,
                code=reward_code,
                allocated=False,
                deleted=False,
                reward_config_id=self.reward_config.id,
                retailer_id=self.reward_config.retailer_id,
            )
            self.db_session.add(reward)
            self.db_session.commit()
            return reward

        return sync_run_query(_query, self.db_session)

    def _register_reward(self) -> requests.Response:
        """
        Registers our customer_card_ref to Jigsaw and returns a new Reward code.
        """
        return self.send_request(
            "POST",
            f"{self.base_url}/order/V4/register",
            json={
                "customer_card_ref": self.customer_card_ref,
                "brand_id": self.config["brand_id"],
                "transaction_value": self.reward_config_required_values["transaction_value"],
            },
            headers={"Token": self._get_auth_token()},
        )

    def fetch_reward(self) -> tuple[Reward, float, float]:
        customer_card_ref, issued = self._generate_customer_card_ref()

        resp = self._register_reward()
        response_payload = self._get_response_body_or_raise_for_status(resp, try_again_call=self._register_reward)

        if response_payload["data"]["balance"] != self.reward_config_required_values["transaction_value"]:
            # TODO: this logic will be expanded in BPL-438, remove # pragma: no cover once implemented
            raise AgentError("Jigsaw: fetched reward balance and transaction value do not match.")  # pragma: no cover

        expiry = self._get_tz_aware_datetime_from_isoformat(response_payload["data"]["expiry_date"])
        reward = self._save_reward(customer_card_ref, response_payload["data"]["number"])
        return reward, issued.timestamp(), expiry.timestamp()

    def fetch_balance(self) -> Any:  # pragma: no cover
        return NotImplementedError

    def __exit__(self, exc_type: type, exc_value: Exception, exc_traceback: "Traceback") -> None:

        if exc_value is not None:
            self.logger.exception(exc_value)

            if self.customer_card_ref is not None and self.retry_task is not None:

                def _query() -> None:

                    self.db_session.execute(
                        insert(TaskTypeKeyValue)
                        .on_conflict_do_nothing()
                        .values(
                            value=self.customer_card_ref,
                            retry_task_id=self.retry_task.retry_task_id,  # type: ignore [union-attr]
                            task_type_key_id=(
                                select(TaskTypeKey.task_type_key_id)
                                .where(
                                    TaskTypeKey.task_type_id
                                    == self.retry_task.task_type_id,  # type: ignore [union-attr]
                                    TaskTypeKey.name == "customer_card_ref",
                                )
                                .scalar_subquery()
                            ),
                        )
                    )
                    self.db_session.commit()

                sync_run_query(_query, self.db_session)
