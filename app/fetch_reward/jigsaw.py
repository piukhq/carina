from datetime import datetime, timezone
from typing import TYPE_CHECKING, Any, Callable, Optional
from uuid import uuid4

import requests

from retry_tasks_lib.db.models import RetryTask, TaskTypeKey, TaskTypeKeyValue
from sqlalchemy.dialects.postgresql import insert
from sqlalchemy.future import select

from app.core.config import redis, settings
from app.db.base_class import sync_run_query
from app.fetch_reward.base import BaseAgent
from app.models import Reward

if TYPE_CHECKING:  # pragma: no cover
    from inspect import Traceback

    from sqlalchemy.orm import Session

    from app.models import RewardConfig


class Jigsaw(BaseAgent):
    """
    Sample agent_config:
    ```yaml
    base_url: "https://dev.jigsaw360.com"
    brand_id: 30
    ```

    Sample getToken success response payload:
    ```json
    {
        "status": 2000,
        "status_description": "OK",
        "messages": [],
        "PartnerRef": "",
        "data": {
            "__type": "Response.getToken:#Jigsaw.API.Service",
            "Token": "sample-auth-token",
            "Expires": "2022-01-19 09:38:00",
            "TestMode": true
        }
    }
    ```

    Sample register success response payload:
    ```json
    {
        "status": 2000,
        "status_description": "OK",
        "messages": [],
        "PartnerRef": "",
        "data": {
            "__type": "Response_Data.cardData:#Order_V4",
            "customer_card_ref": "UUID generated by us",
            "reference": "339069",
            "number": "Reward.code Jigsaw send us back",
            "pin": "",
            "transaction_value": 10,
            "expiry_date": "2024-01-19T23:59:59+00:00",
            "balance": 10,
            "voucher_url": "https://egift.jigsawgiftcardteam.com/evoucher/download?...",
            "card_status": 1
        }
    }
    ```
    """

    redis_token_key = f"{settings.REDIS_KEY_PREFIX}:agent:jigsaw:auth_token"

    def __init__(
        self,
        db_session: "Session",
        reward_config: "RewardConfig",
        config: dict,
        send_request_fn: Callable = None,
        retry_task: RetryTask = None,
    ) -> None:
        super().__init__(db_session, reward_config, config, send_request_fn, retry_task)
        self.base_url: str = self.config["base_url"]
        self.customer_card_ref: Optional[str] = None

    def _get_response_body_or_raise_for_status(self, resp: requests.Response) -> dict:
        # TODO: add error reponse logic, only happy path supported for now.
        resp.raise_for_status()
        response_payload = resp.json()

        if response_payload["status"] == 2000:
            return response_payload
        else:
            raise requests.RequestException

    def _get_tz_aware_datetime_from_isoformat(self, date_time_str: str) -> datetime:
        dt = datetime.fromisoformat(date_time_str)
        if dt.tzinfo is None:
            self.logger.info("Received naive datetime from Jigsaw, assuming UTC timezone.")
            dt = dt.replace(tzinfo=timezone.utc)

        return dt.astimezone(tz=timezone.utc)

    def _request_new_token(self) -> str:
        resp = self.send_request(
            "POST",
            f"{self.base_url}/order/V4/getToken",
            json={
                "Username": settings.JIGSAW_AGENT_USERNAME,
                "Password": settings.JIGSAW_AGENT_PASSWORD,
            },
        )

        response_payload = self._get_response_body_or_raise_for_status(resp)
        expire_in = int(
            self._get_tz_aware_datetime_from_isoformat(response_payload["data"]["Expires"]).timestamp()
            - datetime.now(tz=timezone.utc).timestamp()
        )
        if expire_in < 0:
            raise ValueError("Jigsaw returned an already expired token.")

        token = response_payload["data"]["Token"]
        redis.set(self.redis_token_key, token, expire_in)
        return token

    def _get_auth_token(self) -> str:
        token = redis.get(self.redis_token_key)
        if token is not None:
            return token

        return self._request_new_token()

    def _generate_customer_card_ref(self) -> tuple[str, datetime]:
        customer_card_ref: Optional[str] = None
        if self.retry_task is not None:
            customer_card_ref = self.retry_task.get_params().get("customer_card_ref", None)

        self.customer_card_ref = str(uuid4()) if customer_card_ref is None else customer_card_ref
        return self.customer_card_ref, datetime.now(tz=timezone.utc)

    def _save_reward(self, customer_card_ref: str, reward_code: str) -> Reward:
        def _query() -> Reward:
            reward = Reward(
                id=customer_card_ref,
                code=reward_code,
                allocated=False,
                deleted=False,
                reward_config_id=self.reward_config.id,
                retailer_id=self.reward_config.retailer_id,
            )
            self.db_session.add(reward)
            self.db_session.commit()
            return reward

        return sync_run_query(_query, self.db_session)

    def fetch_reward(self) -> tuple[Reward, float, float]:
        token = self._get_auth_token()
        customer_card_ref, issued = self._generate_customer_card_ref()

        resp = self.send_request(
            "POST",
            f"{self.base_url}/order/V4/register",
            json={
                "customer_card_ref": customer_card_ref,
                "brand_id": self.config["brand_id"],
                "transaction_value": self.reward_config.load_required_fields_values()["transaction_value"],
            },
            headers={"Token": token},
        )
        response_payload = self._get_response_body_or_raise_for_status(resp)

        if response_payload["data"]["balance"] != self.reward_config.load_required_fields_values()["transaction_value"]:
            # TODO: this logic will be expanded in BPL-438, remove # pragma: no cover once implemented
            raise ValueError("fetched reward balance and transaction value do not match.")  # pragma: no cover

        expiry = self._get_tz_aware_datetime_from_isoformat(response_payload["data"]["expiry_date"])
        reward = self._save_reward(customer_card_ref, response_payload["data"]["number"])
        return reward, issued.timestamp(), expiry.timestamp()

    def fetch_balance(self) -> Any:  # pragma: no cover
        return NotImplementedError

    def __exit__(self, exc_type: type, exc_value: Exception, exc_traceback: "Traceback") -> None:

        if exc_value is not None:
            self.logger.exception(exc_value)

            if self.customer_card_ref is not None and self.retry_task is not None:

                def _query() -> None:

                    self.db_session.execute(
                        insert(TaskTypeKeyValue)
                        .on_conflict_do_nothing()
                        .values(
                            value=self.customer_card_ref,
                            retry_task_id=self.retry_task.retry_task_id,  # type: ignore [union-attr]
                            task_type_key_id=(
                                select(TaskTypeKey.task_type_key_id)
                                .where(
                                    TaskTypeKey.task_type_id
                                    == self.retry_task.task_type_id,  # type: ignore [union-attr]
                                    TaskTypeKey.name == "customer_card_ref",
                                )
                                .scalar_subquery()
                            ),
                        )
                    )
                    self.db_session.commit()

                sync_run_query(_query, self.db_session)
